<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    <script src='https://blog.meekdai.com/Gmeek/plugins/GmeekVercount.js'></script><script async src='https://www.googletagmanager.com/gtag/js?id=G-0Z3PHKTB0H'></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js',new Date());gtag('config','G-0Z3PHKTB0H');</script>
    <link rel="icon" href="https://www.czyouge.xyz/blog/avatar.png"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="记忆，你有我有，LLM 不一定有，但它们正在有。">
<meta property="og:title" content="AI会梦见过去吗？解密大模型的记忆进化之路">
<meta property="og:description" content="记忆，你有我有，LLM 不一定有，但它们正在有。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://blog.czyouge.xyz/post/AI-hui-meng-jian-guo-qu-ma-%EF%BC%9F-jie-mi-da-mo-xing-de-ji-yi-jin-hua-zhi-lu.html">
<meta property="og:image" content="https://www.czyouge.xyz/blog/avatar.png">
<title>AI会梦见过去吗？解密大模型的记忆进化之路</title>



</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}

</style>




<body>
    <div id="header">
<h1 class="postTitle">AI会梦见过去吗？解密大模型的记忆进化之路</h1>
<div class="title-right">
    <a href="https://blog.czyouge.xyz" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/czyouge/blog/issues/7" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><p>记忆，你有我有，LLM 不一定有，但它们正在有。</p>
<p>前两天，<a href="https://x.com/GeminiApp/status/1955719137109438768" rel="nofollow">谷歌宣布</a> Gemini 具备了记忆能力。此前，它已经凭借长达 100 万 token 甚至更高的上下文长度，在「短期记忆」上有不错表现——能够在一次会话中保留大量信息。但这一次，Gemini 可以跨越多次对话，从用户的交流中提炼关键细节和偏好，并在下一次交互时主动调用，让对话更自然、更连贯。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/7a0b31d6006e67d73f7edc6541ba882c042ee36e05247d9617807d56ee19f118/68747470733a2f2f692e696d6775722e636f6d2f424646414762572e706e67"><img src="https://camo.githubusercontent.com/7a0b31d6006e67d73f7edc6541ba882c042ee36e05247d9617807d56ee19f118/68747470733a2f2f692e696d6775722e636f6d2f424646414762572e706e67" alt="" data-canonical-src="https://i.imgur.com/BFFAGbW.png" style="max-width: 100%;"></a></p>
<p>事实上，<a href="https://www.theverge.com/news/757743/anthropic-claude-ai-search-past-chats" rel="nofollow">更早几天</a>，Anthropic 才刚刚为自家的 Claude 装上记忆。在一段演示视频中，一位用户休假归来，向 Claude 询问之前聊过的内容。Claude 会在历史聊天中检索相关记录，阅读并总结给用户，然后询问是否要继续原先的项目。</p>
<p>该公司写道：「你再也不会忘记自己的工作了，Claude 现在会记住你们之前的对话，这样你就可以无缝地继续项目，参考之前的讨论，并在你的想法上进行构建，而不必每次都从头开始。」</p>
<p>至于 OpenAI，在这个方向上却已经走出了相当远。<a href="https://mp.weixin.qq.com/s/RNQIGVh5ymXpZ9KMCpNXfQ" rel="nofollow">早在 2024 年 2 月份</a>，该公司就已经为 ChatGPT 上线了记忆功能：当用户与 ChatGPT 聊天时，用户可以要求 ChatGPT 记住特定的内容或让它自行获取详细信息。使用频率越多，ChatGPT 的记忆力就会越好，并且随着时间的推移，用户能明显感觉到效果的提升。</p>
<p>前些天，该公司 CEO 山姆·奥特曼更是表示 GPT-6 的一大改进核心也将会是记忆。他表示：「人们想要记忆，人们想要那些需要让 AI 能够理解他们的产品功能。」</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/0fb2cc8264aca27355110d863e97381aa1340e7f5b7cf51b4b4244db476ae8c2/68747470733a2f2f692e696d6775722e636f6d2f793646514d6b492e706e67"><img src="https://camo.githubusercontent.com/0fb2cc8264aca27355110d863e97381aa1340e7f5b7cf51b4b4244db476ae8c2/68747470733a2f2f692e696d6775722e636f6d2f793646514d6b492e706e67" alt="" data-canonical-src="https://i.imgur.com/y6FQMkI.png" style="max-width: 100%;"></a></p>
<p>而 <a href="https://techcrunch.com/2025/04/16/xai-adds-a-memory-feature-to-grok/" rel="nofollow">xAI 也已经在 4 月份让 Grok 能够记忆多轮对话的内容</a>。并且 Grok 的记忆是透明的：用户可以清楚地看到 Grok 知道的内容，并可选择忘记哪些内容。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/4eebc5f8a845d898ae07803864e9a0469616a1bc705b6d9f83807ceb85001e2b/68747470733a2f2f692e696d6775722e636f6d2f3637614c4b67712e676966"><img src="https://camo.githubusercontent.com/4eebc5f8a845d898ae07803864e9a0469616a1bc705b6d9f83807ceb85001e2b/68747470733a2f2f692e696d6775722e636f6d2f3637614c4b67712e676966" alt="" data-canonical-src="https://i.imgur.com/67aLKgq.gif" style="max-width: 100%;"></a></p>
<p>近段时间来，LLM 记忆这个赛道也越来越拥挤，新的研究、产品不断涌现。这不，字节跳动联合浙大和上交不久前才刚发布一个具备长期记忆能力的多模态智能体 <a href="https://huggingface.co/papers/2508.09736" rel="nofollow">M3-Agent</a>，让记忆能力不再仅限于文本，更是扩展到了视频、音频等多模态数据。</p>
<p>另外，我们也看到了一批关注 AI 记忆的创业公司的诞生，包括提出了 MemGPT 的 Letta AI、提出了 AI 的记忆操作系统 <a href="https://mp.weixin.qq.com/s/vVFbZRw-U9S7fS_Va7ykKA" rel="nofollow">MemOS</a> 的记忆张量（上海）科技有限公司以及我们前段时间报道过的提出了拥有一定的原生记忆能力的<a href="https://mp.weixin.qq.com/s/SMGF77V0z6yoa6G6fDe7WQ" rel="nofollow">非 Transformer 架构 Yan 2.0 Preview 的国内 AI 创企 RockAI</a> 等。</p>
<p>这些案例背后，记忆并不只是「存信息」那么简单，而是涉及存储、检索、提炼和遗忘等复杂机制。</p>
<p>而「记忆」也正在成为大模型进一步蜕变以及智能体进一步走向大规模应用的关键技术，正如 OpenAI前研究高管、Thinking Machines Lab 联合创始人翁荔（<a href="https://www.linkedin.com/in/lilianweng/overlay/about-this-profile/" rel="nofollow">Lilian Weng</a>）在<a href="https://lilianweng.github.io/posts/2023-06-23-agent/" rel="nofollow">其博客文章</a>中展示的那样。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/951c3b2568551732d4982f61b7d8662fe7cf11906995a7f64bdf027c1a7ae0c2/68747470733a2f2f692e696d6775722e636f6d2f454633544436472e706e67"><img src="https://camo.githubusercontent.com/951c3b2568551732d4982f61b7d8662fe7cf11906995a7f64bdf027c1a7ae0c2/68747470733a2f2f692e696d6775722e636f6d2f454633544436472e706e67" alt="" data-canonical-src="https://i.imgur.com/EF3TD6G.png" style="max-width: 100%;"></a></p>
<p>接下来，我们就来看看，LLM 的记忆究竟是如何实现的。</p>
<h1>LLM 记忆的类型以及如何实现 LLM 记忆</h1>
<p>要构建记忆，必定要先定义记忆。这里我们直接引用翁荔的定义：</p>
<blockquote>
<p>记忆可以被定义为获取、存储、保留和随后检索信息的过程。</p>
</blockquote>
<p>她又进一步将记忆分为感官记忆、短期记忆和长期记忆：</p>
<ul>
<li><strong>感官记忆</strong>：学习原始输入（包括文本、图像或其他模态数据）的嵌入表示；</li>
<li><strong>短期记忆</strong>：即在上下文中的记忆——短暂且有限的，因为它受到Transformer有限上下文窗口长度的限制；</li>
<li><strong>长期记忆</strong>：可以跨对话使用的记忆，包括智能体在响应用户查询时可以调用的外部向量存储，可以通过快速检索访问。</li>
</ul>
<p>这里我们不关注感官记忆，同时更加侧重于长期记忆。</p>
<p>根据近期的几篇相关综述报告，我们可以对 LLM 的短期和长期记忆做一个更加详细的归纳分类，包括上下文内记忆、外部记忆、参数化记忆、类人的分层式记忆和情境记忆。</p>
<h2>上下文内记忆</h2>
<p>上下文内记忆是一种短期记忆。</p>
<p>简单来说，就是将需要模型知道的信息放入模型的上下文窗口之中，也就是放入我们发送给模型的提示词（prompt）中。这样一来，模型就可以在执行推理之前先浏览一遍这些信息。这种方法适用于任何有足够长上下文的 LLM，也是一种简单直接的通用方法。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/4e8368a796d4aa1d6762de62cd9355906e7036c05c467dcc74b585d3e64d4f36/68747470733a2f2f692e696d6775722e636f6d2f725336755359452e706e67"><img src="https://camo.githubusercontent.com/4e8368a796d4aa1d6762de62cd9355906e7036c05c467dcc74b585d3e64d4f36/68747470733a2f2f692e696d6775722e636f6d2f725336755359452e706e67" alt="" data-canonical-src="https://i.imgur.com/rS6uSYE.png" style="max-width: 100%;"></a></p>
<p><em>上下文内记忆是 LLM 的短期记忆。图中，上下文窗口被表示为一个消息阵列。最新消息位于数组末尾。消息按从旧到新的顺序排列。「系统消息」不会被移出上下文窗口，因为它包含对模型至关重要的信息——通常是告知 LLM 其被期望行为的具体指令。图源：<a href="https://www.johnsosoka.com/blog/2024/02/19/extend-llm-memory.html" rel="nofollow">johnsosoka.com</a></em></p>
<p>但是，这种方法的缺点也很明显：</p>
<ul>
<li><strong>容量有限</strong>：LLM 的上下文窗口长度终究有限，无法容纳海量信息。</li>
<li><strong>成本高昂</strong>：将大量信息塞入提示词会显著增加每一次推理的计算成本和时间。</li>
<li><strong>临时性</strong>：这部分记忆是「一次性」的，一旦对话会话结束，所有上下文信息都会被遗忘，无法跨会话保留（所以是短期记忆）。</li>
</ul>
<h2>外部记忆</h2>
<p>外部记忆是一种非参数化（是指没有融合进模型的参数之中）的长期记忆。这是为了克服短期记忆的限制而生的，同时也是当前构建长期记忆最主流的方式。</p>
<p>其核心思想是将信息存储在模型外部的数据库中（如向量数据库），在需要时通过信息检索技术（Retrieval）将最相关的内容取回，并注入到当前的上下文窗口中，为模型提供决策依据。这一过程通常被称为「检索增强生成」（Retrieval-Augmented Generation, RAG）。</p>
<p>一个完整的外部记忆系统通常包括三个关键操作 ：</p>
<ul>
<li><strong>记忆写入</strong>：将新的信息（如对话历史、用户偏好）处理后存入外部数据库。</li>
<li><strong>记忆管理</strong>：对已存储的记忆进行更新、合并、去重，甚至遗忘过时或不重要的信息 。</li>
<li><strong>记忆读取</strong>：根据当前的用户查询，从数据库中高效地检索出最相关的记忆片段。</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/f7144cba22e40d5d1a05471927af21974412c5c53a6a338384e25c8316e88f82/68747470733a2f2f692e696d6775722e636f6d2f6d7037485572482e706e67"><img src="https://camo.githubusercontent.com/f7144cba22e40d5d1a05471927af21974412c5c53a6a338384e25c8316e88f82/68747470733a2f2f692e696d6775722e636f6d2f6d7037485572482e706e67" alt="" data-canonical-src="https://i.imgur.com/mp7HUrH.png" style="max-width: 100%;"></a></p>
<p><em>记忆的读取（R）、写入（W）和管理（M）过程，其中虚线表示交叉试验信息可以整合进记忆模块，图源：arXiv:2404.13501</em></p>
<p>这种方法的优势在于灵活性高，可以存储海量信息，并且更新记忆无需重新训练模型 。但它也面临挑战，即检索的准确性和效率至关重要：一旦检索失败或错误，就可能会向模型提供无关甚至错误的「记忆」，从而影响最终输出的质量。</p>
<h2>参数化记忆</h2>
<p>与将记忆存储在外部不同，参数化记忆是试图将信息直接编码进大模型自身的参数（即神经网络的权重）中。这是一种更深层次的「内化记忆」。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/4fba089993073d8c1ccc8ae4d2e6be5186db75689f440aaaaac6b7aced72a151/68747470733a2f2f692e696d6775722e636f6d2f42703834554a592e706e67"><img src="https://camo.githubusercontent.com/4fba089993073d8c1ccc8ae4d2e6be5186db75689f440aaaaac6b7aced72a151/68747470733a2f2f692e696d6775722e636f6d2f42703834554a592e706e67" alt="" data-canonical-src="https://i.imgur.com/Bp84UJY.png" style="max-width: 100%;"></a></p>
<p><em>非参数化记忆与参数化记忆，图源：arXiv:2411.00489</em></p>
<p>实现参数化记忆的方式主要有：</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/bf170810e968c689c30342c389f3256c078de47d1a6b87c8ab7de769252f2400/68747470733a2f2f692e696d6775722e636f6d2f5076304c4b35682e706e67"><img src="https://camo.githubusercontent.com/bf170810e968c689c30342c389f3256c078de47d1a6b87c8ab7de769252f2400/68747470733a2f2f692e696d6775722e636f6d2f5076304c4b35682e706e67" alt="" data-canonical-src="https://i.imgur.com/Pv0LK5h.png" style="max-width: 100%;"></a></p>
<p><em>图源：arXiv:2404.13501</em></p>
<ul>
<li><strong>模型微调</strong>：通过在特定数据集上进行训练，将领域知识或特定人设「注入」模型参数中 。例如，用医疗知识微调模型，使其成为一个专业的「医疗智能体」。</li>
<li><strong>知识编辑</strong>：与需要大量数据和计算的微调不同，知识编辑技术可以精确地修改模型参数中存储的特定事实，同时尽量不影响其他知识，适合小规模、高精度的记忆更新。</li>
<li><strong>轻量化适应</strong>：采用低秩适应（LoRA）等参数高效的微调技术，通过训练一个微小的「外挂」模块来承载新的记忆，从而在不改动庞大基础模型的前提下实现记忆的更新 。</li>
</ul>
<p>参数内记忆的优点是信息一旦被编码，检索速度极快，因为在推理时它就是模型的一部分，没有额外的检索延迟。</p>
<p>但其缺点是记忆的更新成本高昂，通常需要重新训练或微调，并且存在「灾难性遗忘」的风险，即模型在学习新知识时可能会忘记旧的知识 。</p>
<h2>类人的分层式记忆和情境记忆</h2>
<p>为了让 AI 的记忆机制更接近人类，有研究者们从认知科学中汲取了灵感，设计了更复杂的、类似人脑的记忆架构。人类的记忆并非扁平的，而是分为记录具体事件的情景记忆（Episodic Memory，如「我昨天午餐吃了什么」）和存储一般事实与知识的语义记忆（Semantic Memory，如「地球是圆的」）。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/6050ebf8fab0af1dae5e388c30950b5c45488ffc4ea48346605bc57abf47d07c/68747470733a2f2f692e696d6775722e636f6d2f513078507931422e706e67"><img src="https://camo.githubusercontent.com/6050ebf8fab0af1dae5e388c30950b5c45488ffc4ea48346605bc57abf47d07c/68747470733a2f2f692e696d6775722e636f6d2f513078507931422e706e67" alt="" data-canonical-src="https://i.imgur.com/Q0xPy1B.png" style="max-width: 100%;"></a></p>
<p><em>人类记忆与 LLM 记忆的对比，图源：arXiv:2504.15965</em></p>
<p>受此启发，分层式记忆系统被提出，它通过更精细化的记忆管理，实现从原始信息到抽象知识的提炼。</p>
<ul>
<li><strong>记忆整合与提炼</strong>：模型不仅仅是存储原始对话，还会对其进行加工。例如，一个智能体可以先将每天的对话内容总结成一个个具体的「情景记忆」片段。</li>
<li><strong>反思与抽象</strong>：随着时间的推移，智能体会通过「反思」（Reflection）机制，从大量的情景记忆中提炼出更高级、更抽象的「语义记忆」。比如，从「用户 A 连续一周都在下午 3 点询问咖啡推荐」这一情景中，提炼出「用户 A 有下午喝咖啡的习惯」这一语义层面的偏好。</li>
</ul>
<p>这种分层式的记忆结构让 AI 不仅能「记住」发生了什么，更能「理解」这些事情背后的模式和意义，从而做出更智能、更具洞察力的反应。</p>
<p>需要指出，在实际应用中，上述不同类型的记忆并非完全独立，而是经常被组合使用，形成「<strong>混合记忆（Hybrid Memory）</strong>」系统。</p>
<p>举个例子，一个智能体可能用参数内记忆来固化其核心性格，同时利用外部记忆来动态记录与用户的每一次互动，从而兼顾稳定性和灵活性。</p>
<p>另外，这里的分类也并未穷尽，更多的记忆方法也在不断涌现。</p>
<h1>近期一些值得关注的记忆系统</h1>
<p>了解了 AI 获得短期和长期记忆的几种形式，下面我们来看一些具体的记忆实现。</p>
<h2>OpenAI 等大厂是怎么做的？</h2>
<p>OpenAI 的 ChatGPT 的记忆功能<a href="https://openai.com/index/memory-and-new-controls-for-chatgpt/" rel="nofollow">上线于去年 2 月份</a>，用户可以在聊天中显式让 ChatGPT 记住某些东西，比如「记住我喜欢Python编程」或者「记住我的孩子叫Lucy」。这些记忆会被单独存储，后续的对话会将这些信息作为背景注入模型的系统提示词中，让 AI 具备「常识」般记住用户的偏好。用户也可以直接要求它记住/忘记某件事情，并在个人设置中查看和管理这些记忆条目。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/45364de70bf4955453f4ce61fcbc80f2acb200cb3dc70273dc60a426a08853ce/68747470733a2f2f692e696d6775722e636f6d2f55745a585570472e706e67"><img src="https://camo.githubusercontent.com/45364de70bf4955453f4ce61fcbc80f2acb200cb3dc70273dc60a426a08853ce/68747470733a2f2f692e696d6775722e636f6d2f55745a585570472e706e67" alt="" data-canonical-src="https://i.imgur.com/UtZXUpG.png" style="max-width: 100%;"></a></p>
<p><em>ChatGPT 中保存的记忆</em></p>
<p>除了显式记忆，ChatGPT 还能借助最近的对话历史来理解上下文和用户的习惯。从2024年起，OpenAI还实现了「跨会话历史」引用，即 ChatGPT 能在不同会话中，基于之前的交互自动捕捉细节，比如你的表达风格、关注的主题等，从而提供更连贯的服务。</p>
<p>从其描述来看，ChatGPT 实现记忆机制的原理并不复杂：ChatGPT 会将用户记忆以结构化片段保存于服务器端（如向量数据库+常规数据库），再通过提示工程方式，在生成回复时自动将用户记忆片段注入模型参考语境，实现个性化推荐和上下文延续。这类似于给 AI 补充用户专属背景知识库，让 AI「越来越懂你」。</p>
<p>相较之下，Anthropic 的 Claude 的记忆则更加简单一些——它不是像 OpenAI 的 ChatGPT 那样的持久记忆功能；<a href="https://www.theverge.com/news/757743/anthropic-claude-ai-search-past-chats" rel="nofollow">Claude 只会在用户要求时才会检索和引用过去的聊天记录</a>，而且它不会建立用户档案。</p>
<p>而 Gemini 看起来与 ChatGPT 的功能类似，另外还支持用户自己录入想要 Gemini 记住的东西。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/4355a73218ff5e48c54817a4f2595b374eebf1bc46a12b581dfa07537e1a1fab/68747470733a2f2f692e696d6775722e636f6d2f4e7552624544522e706e67"><img src="https://camo.githubusercontent.com/4355a73218ff5e48c54817a4f2595b374eebf1bc46a12b581dfa07537e1a1fab/68747470733a2f2f692e696d6775722e636f6d2f4e7552624544522e706e67" alt="" data-canonical-src="https://i.imgur.com/NuRbEDR.png" style="max-width: 100%;"></a></p>
<p><em>Gemini 支持直接录入记忆</em></p>
<h2>像管理内存一样管理记忆</h2>
<p>上面 ChatGPT、Claude 和 Gemini 处理用户记忆的方式还很简单，核心技术是提示工程。这类方式会受到模型上下文窗口大小的限制，难以承载更多信息。</p>
<p>那如果让记忆本身也智能化呢？论文《<a href="https://arxiv.org/abs/2310.08560" rel="nofollow">MemGPT</a><a href="https://arxiv.org/abs/2310.08560" rel="nofollow">: Towards LLMs as Operating Systems</a>》提出使用一个专门的记忆 LLM 智能体来管理工作 LLM 上下文窗口。</p>
<p>该系统配备了一个大型的持久记忆，用于存储所有可能被纳入输入上下文的信息，而那个智能体的职责则是负责决定哪些信息实际被包含进工作 LLM 的上下文窗口。该技术受传统操作系统中分层内存系统的启发——通过在物理内存与磁盘之间进行分页，实现扩展虚拟内存的假象。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/5e3b4ce4a4cbe9c44fec2bcbb6700b5a1b0b9c8cf3acfaaced18a5e63a183255/68747470733a2f2f692e696d6775722e636f6d2f356437674b494b2e706e67"><img src="https://camo.githubusercontent.com/5e3b4ce4a4cbe9c44fec2bcbb6700b5a1b0b9c8cf3acfaaced18a5e63a183255/68747470733a2f2f692e696d6775722e636f6d2f356437674b494b2e706e67" alt="" data-canonical-src="https://i.imgur.com/5d7gKIK.png" style="max-width: 100%;"></a></p>
<p><em>图源：arXiv:2310.08560</em></p>
<p>如上图所示，在 MemGPT 中，一个有着固定上下文长度的 LLM 处理器配备了分层内存系统和一些函数，使其能够管理自身的记忆。这个 LLM 的提示 token（输入，即主上下文）由系统指令、工作上下文和 FIFO 队列组成。LLM 的完成 token （输出）会被函数执行器解释为函数调用。MemGPT 使用函数在主上下文和外部上下文（归档和调用存储数据库）之间移动数据。LLM 可以通过在其输出中生成一个特殊的关键字参数 (request heartbeat=true) 来请求立即进行后续的 LLM 推理，从而将函数调用链接在一起；函数链使得 MemGPT 能够执行多步检索来回答用户查询。</p>
<h2>为AI记忆打造一个操作系统</h2>
<p>记忆张量（上海）科技有限公司等提出的 <strong>MemOS</strong>（Memory Operating System）则更进一步，借鉴了传统操作系统的分层架构设计，也融合了 Memory3（忆立方）大模型在记忆分层管理方面的核心机制。与传统 RAG 或纯参数存储不同，MemOS 把 「记忆」 看作一种和算力同等重要的系统资源。它通过标准化的 MemCube 记忆单元，将明文、激活状态和参数记忆统一在同一个框架里进行调度、融合、归档和权限管理。简单来说，模型不再只是 「看完即忘」，而是拥有了持续进化和自我更新的能力。</p>
<p>MemOS 整个系统由 API 与应用接口层、记忆调度与管理层、记忆存储与基础设施层三大核心层次组成，构建了一套从用户交互到底层存储的全链路记忆管理闭环。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/66980ee45c073854d4a9bc6608ee9288ae85621f378d4ab5d943e44cfa507141/68747470733a2f2f692e696d6775722e636f6d2f696e3267434f622e676966"><img src="https://camo.githubusercontent.com/66980ee45c073854d4a9bc6608ee9288ae85621f378d4ab5d943e44cfa507141/68747470733a2f2f692e696d6775722e636f6d2f696e3267434f622e676966" alt="" data-canonical-src="https://i.imgur.com/in2gCOb.gif" style="max-width: 100%;"></a></p>
<p><em>MemOS 框架，图源：<a href="http://memos.openmem.net/" rel="nofollow">http://memos.openmem.net/</a></em></p>
<p>在 API 与应用接口层，MemOS 提供了标准化的 Memory API，开发者可以通过简单的接口实现记忆创建、删除、更新等操作，让大模型具备易于调用和扩展的持久记忆能力，支持多轮对话、长期任务和跨会话个性化等复杂应用场景。在记忆调度与管理层，MemOS 提出了记忆调度的全新范式，支持基于上下文的 「下一场景预测」，可以在模型生成时提前加载潜在需要的记忆片段，显著降低响应延迟、提升推理效率。而在记忆存储与基础设施层，MemOS 通过标准化的 MemCube 封装，将明文记忆、激活记忆和参数记忆三种形态有机整合。它支持多种持久化存储方式，包括 Graph 数据库、向量数据库等，并具备跨模型的记忆迁移与复用能力。</p>
<p>无独有偶，北邮百家 AI 团队推出的 <strong>MemoryOS</strong> 则巧妙融合了计算机操作系统原理与人脑分层记忆机制，构建段页式三级存储架构及四大核心模块（存储、更新、检索、生成），提供全链路用户记忆管理方案，让 AI 智能体拥有持久「记性」与深度「个性」。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/80d4e5e9f5ee0c02d694df3c0097ccf7645b0c89952070b11be50bc4bde05ce8/68747470733a2f2f692e696d6775722e636f6d2f773455484a53452e706e67"><img src="https://camo.githubusercontent.com/80d4e5e9f5ee0c02d694df3c0097ccf7645b0c89952070b11be50bc4bde05ce8/68747470733a2f2f692e696d6775722e636f6d2f773455484a53452e706e67" alt="" data-canonical-src="https://i.imgur.com/w4UHJSE.png" style="max-width: 100%;"></a></p>
<p><em>MemoryOS 架构概况，图源：arXiv:2506.06326</em></p>
<h2>记忆的分层细化</h2>
<p>从上面几个项目可以看出，记忆管理的一个重要方面是分层。这其实也很好理解，正如人类的记忆一样，LLM 的记忆同样也有轻重缓急。</p>
<p>在这方面，<strong>MIRIX</strong> 是近期一个较为亮眼的项目，其将记忆细分成了 6 类来进行处理：核心记忆、情景记忆、语义记忆、程序记忆、资源记忆、知识金库。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/a004a4a3cc60eb8f57a259c2e51512c6110044abff76051df3dfcb8435db80b0/68747470733a2f2f692e696d6775722e636f6d2f5969425378706e2e706e67"><img src="https://camo.githubusercontent.com/a004a4a3cc60eb8f57a259c2e51512c6110044abff76051df3dfcb8435db80b0/68747470733a2f2f692e696d6775722e636f6d2f5969425378706e2e706e67" alt="" data-canonical-src="https://i.imgur.com/YiBSxpn.png" style="max-width: 100%;"></a></p>
<p><em>MIRIX 的六个记忆组件，每一个都有自己的专属功能。图源：2507.07957</em></p>
<p>基于此，MIRIX 可以先理解需求，再决定在哪种记忆中搜索，再组合答案。也就是说：它会思考「我要回忆什么」，而不是机械地索引。</p>
<p>具体来说，他们提出了一种模块化多智能体架构，由若干专用组件在统一调度机制下协作完成输入处理、记忆更新和信息检索。整个系统包括：元记忆管理器（Meta Memory Manager）、记忆管理器（Memory Managers）以及对话智能体（Chat Agent）。</p>
<p>在记忆更新时，当系统接收到新的输入（如用户提供的文本、推断出的事件、上传的文件）时，会按如下流程进行处理：初步检索→路由与分析→并行更新→完成确认。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/9e51761456a5dae04cbf8810b802de82d3241e122d4bf1c3a1b6eff93b326c56/68747470733a2f2f692e696d6775722e636f6d2f42363854424a6d2e706e67"><img src="https://camo.githubusercontent.com/9e51761456a5dae04cbf8810b802de82d3241e122d4bf1c3a1b6eff93b326c56/68747470733a2f2f692e696d6775722e636f6d2f42363854424a6d2e706e67" alt="" data-canonical-src="https://i.imgur.com/B68TBJm.png" style="max-width: 100%;"></a></p>
<p><em>MIRIX 的记忆更新工作流程，图源：2507.07957</em></p>
<p>在对话检索时，检索流程的主要步骤是：粗检索→目标检索选择→精细检索→结果整合与答案生成→交互式更新。这一流程可确保系统的回答不仅有一致性，也能根据最新知识动态调整。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/e4491122ec4dcb98ca0d8e2ff25b6cce53fddabd747903e167de433160396f22/68747470733a2f2f692e696d6775722e636f6d2f76514f304e74392e706e67"><img src="https://camo.githubusercontent.com/e4491122ec4dcb98ca0d8e2ff25b6cce53fddabd747903e167de433160396f22/68747470733a2f2f692e696d6775722e636f6d2f76514f304e74392e706e67" alt="" data-canonical-src="https://i.imgur.com/vQO0Nt9.png" style="max-width: 100%;"></a></p>
<p><em>MIRIX 的对话检索工作流程，图源：2507.07957</em></p>
<h2>结构化记忆与图式记忆</h2>
<p>在处理大模型所要记忆的内容时，一种常见的方法是将记忆转化为向量数据库：也就是把文本型的记忆信息转成嵌入（Embedding）向量，存入数据库中。这样，当用户再次提问时，系统可以通过语义检索快速找到相关的记忆，再交给模型使用，其流程大致是：信息提取 → 向量化（Embedding） → 存入向量数据库 → 检索增强生成（RAG）。</p>
<p>不过，这种方法也存在一定的缺点：</p>
<ul>
<li>记忆容易冗余：如果信息太多，存储空间和检索成本都会增加。</li>
<li>缺乏层次和结构：向量检索找到的是「语义相似」，但不能很好地表达时间顺序、因果关系或知识结构。</li>
<li>检索不稳定：有时会找不到真正相关的信息，或者返回「相似但不正确」的片段。</li>
</ul>
<p>因此，在记忆系统的构建中，一个重要的探索方向是对需要 AI 记忆的内容进行提炼、压缩和结构化处理。这不仅能提升记忆容量，也能让模型在回忆时更准确、更高效。具体方法包括：</p>
<ul>
<li>把知识点存储成数据库条目，带有清晰的键值和属性。</li>
<li>用图（Graph）结构来表示实体之间的联系，方便模型理解因果、上下位关系。</li>
<li>甚至可以结合多层记忆：短期向量记忆（快速检索）+ 长期结构化记忆（稳定存储）。</li>
</ul>
<p>举个例子，新加坡国立大学和同济大学等提出的 G-Memory 设计了一个三层图式基于模型，分别为洞察图、查询图和交互图。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/d07fb3d312acf88391185f207f9590fdaec76ca9ecb24c49f9d840ad3f1a7a2c/68747470733a2f2f692e696d6775722e636f6d2f506549357542742e706e67"><img src="https://camo.githubusercontent.com/d07fb3d312acf88391185f207f9590fdaec76ca9ecb24c49f9d840ad3f1a7a2c/68747470733a2f2f692e696d6775722e636f6d2f506549357542742e706e67" alt="" data-canonical-src="https://i.imgur.com/PeI5uBt.png" style="max-width: 100%;"></a></p>
<p><em>G-Memory 概况，中间可以看到其三层图式记忆架构，图源：2506.07398</em></p>
<p>其中，洞察图用于捕捉单智能体对环境与交互的主观理解，查询图是统一智能体间的任务需求与意图表达，而交互图则能显式地建模各智能体之间的协作路径、沟通历史与记忆共享权限。</p>
<p>通过这种分层记忆图式结构，G-Memory支持「定制化记忆视角」与「跨智能体语义映射」，可有效解决多智能体间记忆污染和路径冲突等协同问题，也为异质智能体系统构建了可扩展的记忆编排范式。</p>
<h2>多模态记忆</h2>
<p>随着多模态时代的到来，AI 系统不仅要理解和记住文本，还需要处理图像、视频、音频等多模态信息，对多模态记忆的需求也随之产生。相比文本，多模态记忆的难点在于信息量巨大、时序关系复杂、知识结构分散，这对 AI 的存储与检索能力提出了更高的挑战。</p>
<p>为应对这些挑战，AI 社区正在积极探索不同的解决方案。</p>
<p>其中，<a href="https://mp.weixin.qq.com/s/3MlrQlOSGLZ6Iq7FCCdqyQ" rel="nofollow">由前 Meta Reality Labs 顶尖科学家团队创立的研究实验室 Memories.ai 提出了「大视觉记忆模型」（LVMM）</a>。</p>
<p>这一模型为 AI 系统引入了革命性的视觉记忆层：它突破了传统 AI 在视频处理中仅限于「片段式分析」的局限，转而能够持续捕获、存储和结构化海量的视觉数据。这样，AI 不仅能够永久保留上下文信息，还能精准识别时序模式、进行智能对比分析。换句话说，该平台可以将原始视频转化为可搜索、带有上下文关联的数据库，从而赋予 AI 系统类似人类的持续学习能力，配备上了一个几乎无限的「视觉大脑」。</p>
<p>与此同时，国内也出现了新的探索。字节跳动联合浙江大学和上海交通大学发布了 M3-Agent。这是一种具备长期记忆能力的多模态智能体。其架构由多模态大语言模型（MLLM）和多模态长期记忆模块组成，整体分为「记忆（memorization）」与「控制（control）」两大并行过程：</p>
<ul>
<li>在记忆阶段，M3-Agent 能够实时处理视频与音频流，并生成「情节记忆」和「语义记忆」；</li>
<li>在控制阶段，系统则依托长期记忆进行推理和任务执行，能够跨事件、角色等多个维度自主检索相关信息。</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/de4d743d01bbcbbf354587ed5ad0445ad0088211f94f7d19c8d957238dc46c78/68747470733a2f2f692e696d6775722e636f6d2f326d646f4369322e706e67"><img src="https://camo.githubusercontent.com/de4d743d01bbcbbf354587ed5ad0445ad0088211f94f7d19c8d957238dc46c78/68747470733a2f2f692e696d6775722e636f6d2f326d646f4369322e706e67" alt="" data-canonical-src="https://i.imgur.com/2mdoCi2.png" style="max-width: 100%;"></a></p>
<p><em>M3-Agent 架构，图源：arXiv:2508.09736</em></p>
<p>值得注意的是，M3-Agent 并非依赖单轮的 RAG 来调用记忆，而是通过强化学习驱动的多轮推理与迭代记忆检索，从而显著提升任务完成率。</p>
<p>此外，M3-Agent 在长期视频处理方面提出了两项关键突破：</p>
<ul>
<li><strong>无限信息处理</strong>：不再局限于离线、有限长度的视频，而是能够持续处理任意长的多模态输入流，更接近人类长期记忆的形成方式。</li>
<li><strong>世界知识构建</strong>：传统方法往往停留在低层次的视觉描述，而 M3-Agent 通过实体中心化的记忆结构，逐步积累角色身份、实体属性等高层知识，从而保证长期上下文的一致性与连贯性。</li>
</ul>
<p>通过这些探索，可以看到多模态记忆正从「存储片段」走向「构建世界」，这无疑将成为下一代智能体实现真正长期学习与理解的关键。</p>
<h2>将记忆原生融入模型</h2>
<p>除了外挂式的记忆机制，也有一些探索尝试将记忆能力直接融入模型自身。最基本的方法是基于需要记忆的数据对模型进行再训练，让记忆「写入」参数，比如使用 LoRA 或测试时训练来进行记忆参数化。然而，近期学界和业界也出现了一些更加有趣的尝试。</p>
<p>Meta 在论文 《Memory Layers at Scale》 中提出了「记忆层」（memory layers）的概念。按照传统做法，语言模型的信息主要存储在网络权重中，而提升记忆能力通常依赖于扩大参数规模。但这种方式的代价是巨大的计算和能耗，而且对于一些「简单的关联记忆」（如名人生日、国家首都、概念间的对应关系），并非最优解。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/5095e55763495e831e58ae108273958a51e02c55eb458fb57d1d41fb75e5f62a/68747470733a2f2f692e696d6775722e636f6d2f484c743148434d2e706e67"><img src="https://camo.githubusercontent.com/5095e55763495e831e58ae108273958a51e02c55eb458fb57d1d41fb75e5f62a/68747470733a2f2f692e696d6775722e636f6d2f484c743148434d2e706e67" alt="" data-canonical-src="https://i.imgur.com/HLt1HCM.png" style="max-width: 100%;"></a></p>
<p><em>左图为常规记忆层，右图为改进的 Memory+ 模块，图源：arXiv:2412.09764</em></p>
<p>记忆层则提供了一种更加自然且高效的路径。其核心思想是通过键-值对检索机制来实现关联存储与调用，即以 embedding 表示键和值，实现一种神经网络内部的「查表式记忆」。早期虽然有类似的工作（如 Memory Networks、Neural Turing Machine），但并未在大规模 AI 架构中真正发挥作用。Meta 的研究突破在于将 Transformer 中的前馈网络（FFN）替换为记忆层，并保持其他部分不变。</p>
<p>Meta 还在大规模实验中验证了记忆层的可扩展性，其记忆容量可达 1280 亿参数级别，相比以往提升了两个数量级。</p>
<p>这表明，记忆层有潜力成为下一代大模型的核心组件。</p>
<p>另外，Meta 去年提出的 Branch-Train-MiX （BTX）方法也有望成为一种实现参数化记忆的手段，其包含三个主要步骤。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/d2ab9ce1e99843b3f2e9f6ef72bd48f0808c293126bc6035258d6584a299816a/68747470733a2f2f692e696d6775722e636f6d2f333678596c456f2e706e67"><img src="https://camo.githubusercontent.com/d2ab9ce1e99843b3f2e9f6ef72bd48f0808c293126bc6035258d6584a299816a/68747470733a2f2f692e696d6775722e636f6d2f333678596c456f2e706e67" alt="" data-canonical-src="https://i.imgur.com/36xYlEo.png" style="max-width: 100%;"></a></p>
<p><em>BTX 方法概况，图源：arXiv:2403.07816</em></p>
<ol>
<li>在 Branch 和 Train 阶段，会基于预训练的种子模型创建多个副本（称为专家模型），并在不同的数据子集上进行独立训练，每个副本对应一个特定的知识领域，例如数学、编程或百科。此训练过程并行且异步，从而可降低通信成本并提高训练吞吐量。</li>
<li>接下来，在 MiX 阶段，这些专家模型的前向子层被合并为一个 MoE 模块，形成统一的 MoE 模型。在每个 Transformer 层中，使用路由网络来选择将哪个专家的前馈子层应用于每个 token。自注意力子层和其他模块的权重通过简单的平均进行合并。</li>
<li>最后，在 MoE 微调阶段，合并后的模型在整个训练数据集上进一步微调，使路由网络能够学习在测试期间如何在不同专家之间动态路由 token。</li>
</ol>
<p>与此同时，另一条不同的路径来自国内 AI 创企 RockAI，其提出的 <a href="https://mp.weixin.qq.com/s/SMGF77V0z6yoa6G6fDe7WQ" rel="nofollow">Yan 2.0 Preview 模型</a>具有「原生记忆能力」，能够在推理的同时把记忆直接融入参数中。值得注意的是，它并未采用常规的 Transformer 架构和注意力机制，而是基于 Yan 架构。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/cf921779c4e721c1f9fff1b07a98d496dac54c76f2f3e6fc2b2eec37b9998d9b/68747470733a2f2f692e696d6775722e636f6d2f336634553879492e706e67"><img src="https://camo.githubusercontent.com/cf921779c4e721c1f9fff1b07a98d496dac54c76f2f3e6fc2b2eec37b9998d9b/68747470733a2f2f692e696d6775722e636f6d2f336634553879492e706e67" alt="" data-canonical-src="https://i.imgur.com/3f4U8yI.png" style="max-width: 100%;"></a></p>
<p><em>Yan 2.0 Preview 架构示意图</em></p>
<p>Yan 2.0 Preview 通过一个可微分的「神经网络记忆单元」实现记忆的存储、检索和遗忘。</p>
<p>与外挂知识库不同，这种方式更接近生物记忆：模型会将理解过的信息内化为权重的一部分，形成一种真正「自身的记忆」。在使用体验上，这意味着用户无需再手动管理知识库（增删改查），而是可以依赖模型实现端到端的记忆与调用。</p>
<h1>关键挑战与未来趋势</h1>
<p>构建一个真正强大、可靠且智能的 LLM 记忆系统，其难度不亚于模型本身的研发。尽管我们已经看到了诸多创新，但前路依然充满挑战。结合相关综述报告、技术博客以及学术界的深入探讨，我们可以将这些挑战与未来的发展趋势归纳为以下几个方面。</p>
<h2>1.挑战：从数据堆砌到智能管理——学习遗忘与整合</h2>
<p>遗忘其实与记忆一样重要，而当前许多记忆系统，特别是基于外部数据库的方案，更像是一个信息仓库，面临着只进不出的困境。</p>
<ul>
<li><strong>失控的记忆增长</strong>：模型缺乏类似人脑的有效遗忘机制 。在没有主动干预的情况下，记忆会无限累积，不仅增加了存储和检索的负担，还可能因为过时或无关的信息干扰而降低决策质量。</li>
<li><strong>信息冲突与更新难题</strong>：当新旧信息或多个信息源发生冲突时，模型往往难以像人类一样巧妙地进行整合与更新，形成新的、更准确的记忆。如何让模型自动解决记忆间的矛盾，是实现动态和自适应记忆的关键。</li>
</ul>
<p>未来的研究需要为 AI 设计更精巧的记忆管理机制，让它学会断舍离，主动遗忘不再重要的信息，并智能地融合新知识。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/3288801c67ce3f5bb952d4ebcf8307b6405f8086f40eaadc3ab6dc32ace7a473/68747470733a2f2f692e696d6775722e636f6d2f397570564830552e706e67"><img src="https://camo.githubusercontent.com/3288801c67ce3f5bb952d4ebcf8307b6405f8086f40eaadc3ab6dc32ace7a473/68747470733a2f2f692e696d6775722e636f6d2f397570564830552e706e67" alt="" data-canonical-src="https://i.imgur.com/9upVH0U.png" style="max-width: 100%;"></a></p>
<p><em>arXiv:2411.00489 中提出的 Self-Adaptive Long-term Memory (SALM) 架构中包含了长期记忆的遗忘阶段</em></p>
<h2>2.挑战：效率、成本与可扩展性的不可能三角</h2>
<p>不同的记忆方案在效率和成本之间面临着艰难的权衡。</p>
<ul>
<li><strong>外部记忆的延迟</strong>：虽然灵活，但依赖 RAG 的外部记忆系统在每次查询时都需要经过「检索→注入上下文」的步骤，这带来了额外的计算延迟，限制了其在实时应用中的表现 。</li>
<li><strong>参数记忆的僵化</strong>：将记忆写入模型参数虽然能实现快速调用，但更新成本极为高昂。无论是完全微调还是知识编辑，都难以支持需要频繁更新记忆的在线学习或终身学习场景。</li>
</ul>
<p>未来的方向在于探索更高效的混合记忆架构，以及更轻量化、低成本的参数内记忆更新技术，以平衡记忆的灵活性、调用速度和更新成本。</p>
<h2>3.趋势：从功能模拟到结构仿生——走向多模态与综合记忆系统</h2>
<p>未来的 LLM 记忆将不再局限于单一功能，而是朝着更全面、更类似人脑的综合系统演进。</p>
<ul>
<li><strong>迈向多模态记忆</strong>：正如人类通过视觉、听觉、触觉等多种感官形成记忆，AI 的记忆也正从纯文本扩展到图像、音频、视频等多模态数据 。一个能记住用户长相、声音和对话场景的智能体，无疑将提供远超文本交互的个性化体验。</li>
<li><strong>构建综合记忆架构</strong>：当前研究多集中于记忆的某个特定方面（如短期对话或长期知识）。未来的先进系统将整合不同类型的记忆模块（类似人类的感官记忆、工作记忆、情景记忆和语义记忆）让它们协同工作，形成一个多层次、多维度、能够自适应的综合记忆中枢 。</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/a7084afbc8b75e9650e35654741fe840de92a3121d12ed89275cb345b3d62360/68747470733a2f2f692e696d6775722e636f6d2f746c6875554d6a2e706e67"><img src="https://camo.githubusercontent.com/a7084afbc8b75e9650e35654741fe840de92a3121d12ed89275cb345b3d62360/68747470733a2f2f692e696d6775722e636f6d2f746c6875554d6a2e706e67" alt="" data-canonical-src="https://i.imgur.com/tlhuUMj.png" style="max-width: 100%;"></a></p>
<p><em>图源：<a href="https://www.youtube.com/live/n-slj72yx8w?si=St48Q9D_h-RFwB5g" rel="nofollow">https://www.youtube.com/live/n-slj72yx8w?si=St48Q9D_h-RFwB5g</a></em></p>
<h2>4.趋势：从孤立个体到记忆互联——智能体间的共享与协作</h2>
<p>随着多智能体系统的兴起，记忆的边界正在从单个智能体扩展到智能体网络。</p>
<ul>
<li><strong>共享记忆</strong>：未来的智能体集群将能够访问一个共享的记忆池，或者在彼此之间传输、同步记忆。比如，一个精通医疗的智能体可以将它的知识记忆共享给一个金融智能体，以协作完成复杂的跨领域任务。</li>
<li><strong>集体智能与隐私</strong>：这种记忆的互联将催生更强大的集体智能，但也带来了新的挑战，例如如何在协作与竞争中管理信息不对称 ，以及如何保护从个人数据聚合而来的集体隐私 。</li>
</ul>
<h2>5.终极目标：从规则演化到自动演化</h2>
<p>目前，智能体的反思和成长在很大程度上仍依赖于人类预先设定的规则。终极目标是实现记忆的自动演化，即<strong>智能体能够根据与环境的持续互动，自主地学习如何管理和优化其记忆，动态调整策略，并最终实现无需人工干预的终身学习。</strong></p>
<p>正如天桥脑科学研究院和普林斯顿大学等发布的《<a href="https://mp.weixin.qq.com/s/BwIazafPjpQFtivIXTs5XA" rel="nofollow">Long Term Memory : The Foundation of AI Self-Evolution</a>》中写到的一样：「模型的自我进化能力是模型长期适应和个性化的关键，而这又严重仰赖于有效的记忆机制。」</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/ec7f1d595a71a4f439258d79670748e3ea0e1fd128aee638a78ff76534e1518c/68747470733a2f2f692e696d6775722e636f6d2f384874324741552e706e67"><img src="https://camo.githubusercontent.com/ec7f1d595a71a4f439258d79670748e3ea0e1fd128aee638a78ff76534e1518c/68747470733a2f2f692e696d6775722e636f6d2f384874324741552e706e67" alt="" data-canonical-src="https://i.imgur.com/8Ht2GAU.png" style="max-width: 100%;"></a></p>
<p><em>arXiv:2410.15665 中给出的长期记忆与 AI 自我进化示意图</em></p>
<p>当它真正实现时，这不仅将是记忆技术的飞跃，更是通往通用人工智能（AGI）的关键一步。</p>
<h1>从「数据档案」到「认知核心」，记忆正在重塑AI的本质</h1>
<p>回望全文，我们不难发现，记忆正在成为划分 AI 新旧时代的「分水岭」。它将大型语言模型从一个 stateless（无状态）的、一次性的「文本计算器」，转变为一个 stateful（有状态）的、能够积累经验并持续演化的「认知主体」。</p>
<p>我们见证了这场变革的完整路径：从受限于上下文长度、昙花一现的短期记忆，到以 RAG 为代表、将信息存储于模型之外的外部记忆，再到尝试将知识内化为模型一部分、挑战与机遇并存的参数化记忆。这些探索的本质，是让 AI 从「使用信息」走向「拥有经验」。如今，行业已经不再满足于让 AI 仅仅记住事实，而是开始系统性地设计它应该如何记忆、如何反思、如何提炼，乃至如何遗忘——这标志着我们正在从构建「数据档案」迈向构建 AI 的「认知核心」。</p>
<p>展望未来，AI 记忆的发展将不再是单一技术的线性优化，而是一场深刻的架构革命。其终极形态，或许是一个能高度模拟人脑机制的综合认知记忆系统。在这样的系统中，记忆不再是被动调用的知识库，而是驱动模型构建和更新其内部「世界模型」的主动引擎。</p>
<p>这个未来的记忆系统将具备三大特征：</p>
<ul>
<li><strong>多模态原生(Multimodal Native)</strong>：它将不再区分文本、图像或声音，而是将所有感官输入无缝融合成统一的、包含丰富情境的多模态记忆，形成对物理世界更完整、更深刻的理解 。</li>
<li><strong>终身自主演化(Lifelong Autonomous Evolution)</strong>：它将具备近乎生物的终身学习能力 ，能通过持续的自我反思与记忆整合，在没有人类强干预的情况下不断成长。遗忘不再是被动的清除，而是一种主动的、为吸收新知识而优化内存的智能策略。</li>
<li><strong>社会化与协同(Social &amp; Collaborative)</strong>：记忆将突破单个智能体的限制，通过共享记忆机制，构建起智能体间的「集体意识」 。专业化的智能体可以像人类专家一样交流、协作，共同完成远超个体能力的复杂任务。</li>
</ul>
<p>这场关于记忆的探索，其意义已远超技术本身。我们正试图赋予机器一段连贯的「生命历程」，让它拥有自己的「过去」，并以此塑造它的「现在」和「未来」。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/f9fdc6e1278ddd1f953814c6bd953cce5453f049c2f38f3cd9211c4f26f6db78/68747470733a2f2f692e696d6775722e636f6d2f646b72775234642e706e67"><img src="https://camo.githubusercontent.com/f9fdc6e1278ddd1f953814c6bd953cce5453f049c2f38f3cd9211c4f26f6db78/68747470733a2f2f692e696d6775722e636f6d2f646b72775234642e706e67" alt="" data-canonical-src="https://i.imgur.com/dkrwR4d.png" style="max-width: 100%;"></a></p>
<p><em>AI 发展史以及未来预测，英文源图：<a href="https://www.concentrix.com/insights/blog/a-guide-to-the-evolution-of-ai/" rel="nofollow">Concentrix</a></em></p>
<p>当一个 AI 能够凭借其积累的记忆，展现出独特的「个性」、形成稳定的「价值观」、甚至与我们建立起深刻的情感连接时，那或许才是 AGI 真正到来的拂晓时分。我们教机器记忆，最终可能是在创造一种全新的、能够与我们共同演化的智能生命。</p>
<h1>参考链接</h1>
<ol>
<li><a href="https://arxiv.org/abs/2404.13501" rel="nofollow">https://arxiv.org/abs/2404.13501</a></li>
<li><a href="https://arxiv.org/pdf/2504.15965v2" rel="nofollow">https://arxiv.org/pdf/2504.15965v2</a></li>
<li><a href="https://lilianweng.github.io/posts/2023-06-23-agent/" rel="nofollow">https://lilianweng.github.io/posts/2023-06-23-agent/</a></li>
<li><a href="https://arxiv.org/pdf/2504.02441" rel="nofollow">https://arxiv.org/pdf/2504.02441</a></li>
<li><a href="https://www.cnbc.com/2025/08/19/sam-altman-on-gpt-6-people-want-memory.html" rel="nofollow">https://www.cnbc.com/2025/08/19/sam-altman-on-gpt-6-people-want-memory.html</a></li>
<li><a href="https://x.com/unwind_ai_/status/1957998921835298946" rel="nofollow">https://x.com/unwind_ai_/status/1957998921835298946</a></li>
<li><a href="https://arxiv.org/abs/2411.00489" rel="nofollow">https://arxiv.org/abs/2411.00489</a></li>
</ol></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://blog.czyouge.xyz">虫子游戈</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if("03/08/2025"!=""){
    var startSite=new Date("03/08/2025");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","czyouge/blog");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}



</script>
<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script>

</html>
